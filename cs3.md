


## **Process Management 1 â€“ Contact Session 3**

## **1. Process Overview**

### **What is a Process?**
- A process is a program in execution. It includes:
  - **Program Code**: Instructions to be executed.
  - **Current Activity**: Values in the program counter, CPU registers.
  - **Process Control Block (PCB)**: Data structure maintained by the operating system for each process.

### **Characteristics of a Process**
- **State**: Processes transition between states like new, ready, running, waiting, and terminated.
- **Resources**: Processes require CPU, memory, I/O devices, etc.
- **Isolation**: Each process operates in its own memory space.

### **Types of Processes**
- **User Process**: Executed by users (e.g., text editors, browsers).
- **System Process**: Managed by the OS (e.g., disk scheduling, networking).

---

## **2. Memory Layout of a Process**

### **Memory Segments**
1. **Text Segment**:
   - Stores the program code.
   - Read-only to prevent accidental modification.
2. **Data Segment**:
   - Contains global and static variables.
   - Divided into initialized and uninitialized (BSS) sections.
3. **Heap Segment**:
   - Used for dynamic memory allocation during runtime.
   - Grows upwards.
4. **Stack Segment**:
   - Stores function calls, local variables, and return addresses.
   - Grows downwards.

### **Diagram:**
```
+------------------+
| Command-line args|
| and Environment  |
+------------------+
|       Stack      | <-- Grows Down
+------------------+
|       Heap       | <-- Grows Up
+------------------+
|  BSS (Uninit.)   |
+------------------+
| Initialized Data |
+------------------+
|    Text Segment  |
+------------------+
```

---

## **3. Process Address Space**

### **Definition**
- A process's address space is the set of memory addresses the process can use.

### **Components**
- **Logical Address Space**:
  - Addresses generated by the CPU.
- **Physical Address Space**:
  - Actual memory addresses in RAM.
  - Translated by the Memory Management Unit (MMU).

### **Advantages**
- Provides **isolation** for processes.
- Enables virtual memory, allowing processes to use more memory than physically available.

---

## **4. Process Creation**

### **Steps in Process Creation**
1. **Forking**:
   - The `fork()` system call creates a new process.
   - The child process is a copy of the parent process.
2. **Execution**:
   - The child process uses the `exec()` family of functions to load a new program.

### **Example in C**:
```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        // Child process
        printf("This is the child process\n");
    } else {
        // Parent process
        printf("This is the parent process\n");
    }
    return 0;
}
```

### **Real-World Use Case**:
- **Web Servers**: Apache spawns a new process to handle each client request.

---

## **5. Process Synchronization**

### **Why is Synchronization Needed?**
- Multiple processes may access shared resources (e.g., memory, files).
- Synchronization ensures **data consistency** and avoids **race conditions**.

### **Mechanisms for Synchronization**
1. **Semaphores**:
   - Counting mechanism to control resource access.
   - Example: `P()` and `V()` operations.
2. **Mutex**:
   - Ensures mutual exclusion by allowing only one process to access a critical section.
3. **Monitors**:
   - High-level abstraction for managing shared resources.

### **Example in C (Semaphore)**:
```c
#include <semaphore.h>
sem_t semaphore;

void critical_section() {
    sem_wait(&semaphore); // Enter critical section
    // Perform task
    sem_post(&semaphore); // Exit critical section
}
```

### **Real-World Example**:
- Synchronizing access to a shared database in a banking system to avoid data corruption.

---

## **6. Process Execution**

### **Steps in Process Execution**
1. **Scheduling**:
   - The OS decides which process gets CPU time.
   - Algorithms: Round Robin, Priority Scheduling.
2. **Context Switching**:
   - The OS saves the state of one process and loads the state of another.
   - Overhead but ensures multitasking.

### **Execution Phases**:
1. **Fetch**: Retrieve instruction from memory.
2. **Decode**: Interpret the instruction.
3. **Execute**: Perform the operation.

### **Example**:
- Running a Python script:
  ```bash
  python3 script.py
  ```

### **Real-World Scenario**:
- A video player process retrieves frames, decodes them, and displays them, all while fetching more frames in the background.

---

## **Conclusion**
- Process management is a cornerstone of operating systems, enabling efficient multitasking and resource sharing.
- Understanding process lifecycle, memory layout, synchronization, and execution is crucial for developing robust applications.
